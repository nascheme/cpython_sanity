name: Python version check and dispatch

on:
  schedule:
    # Weekly on Monday at 06:00 UTC
    - cron: '0 6 * * MON'
  workflow_dispatch: {}

permissions:
  contents: read
  actions: write

jobs:
  check-and-dispatch:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - python_minor: "3.13"
            pre_release: false
          - python_minor: "3.14"
            pre_release: false
          - python_minor: "3.15"
            pre_release: true
    env:
      SMTP_HOST: ${{ secrets.SMTP_HOST }}
      SMTP_PORT: ${{ secrets.SMTP_PORT }}
      SMTP_USER: ${{ secrets.SMTP_USER }}
      SMTP_PASS: ${{ secrets.SMTP_PASS }}
      EMAIL_TO: ${{ secrets.EMAIL_TO }}
      EMAIL_FROM: ${{ secrets.EMAIL_FROM }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Determine latest ${{ matrix.python_minor }} release
      id: get_release
      run: |
        set -euo pipefail
        echo "Fetching releases from python.org..."
        PRE_FLAG=""
        if [ "${{ matrix.pre_release }}" = "true" ]; then
          PRE_FLAG="--pre-release"
        fi
        latest=$(python3 .github/scripts/get_latest_python.py ${{ matrix.python_minor }} $PRE_FLAG || true)
        if [ -z "$latest" ]; then
          echo "found=false" >> $GITHUB_OUTPUT
        else
          VERSION="${latest}t"
          echo "found=true" >> $GITHUB_OUTPUT
          echo "tag=$latest" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "gil_version=$latest" >> $GITHUB_OUTPUT
        fi

    - name: Exit if no ${{ matrix.python_minor }} release found
      if: steps.get_release.outputs.found != 'true'
      run: |
        echo "No ${{ matrix.python_minor }} release found. Nothing to do.";

    - name: Resolve numpy and scipy versions
      if: steps.get_release.outputs.found == 'true'
      id: lib_versions
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        numpy_ver=$(python3 .github/scripts/get_latest_github_release.py numpy/numpy || true)
        echo "numpy_version=${numpy_ver}" >> $GITHUB_OUTPUT
        echo "Resolved numpy=${numpy_ver}"

    - name: Login to GHCR for image checks
      if: steps.get_release.outputs.found == 'true'
      uses: docker/login-action@v3
      with:
       registry: ghcr.io
       username: ${{ secrets.GHCR_USERNAME || github.repository_owner }}
       password: ${{ secrets.CI_TOKEN }}

    - name: Check GHCR for existing images
      if: steps.get_release.outputs.found == 'true'
      id: check_images
      env:
        VERSION: ${{ steps.get_release.outputs.version }}
        GIL_VERSION: ${{ steps.get_release.outputs.gil_version }}
      run: |
        set -euo pipefail

        inspect_image() {
          local ref="$1"
          local out
          if docker manifest inspect "$ref" >/dev/null 2>&1; then
            return 0
          fi
          out=$(docker manifest inspect "$ref" 2>&1 || true)
          if echo "$out" | grep -qiE 'unauthorized|authentication required|denied'; then
            return 2
          fi
          return 1
        }

        # Free-threaded images (tagged with VERSION, e.g. 3.14.3t)
        ft_images=(cpython-tsan cpython-asan numpy-tsan numpy-asan)
        missing=()

        for img in "${ft_images[@]}"; do
          ref="ghcr.io/nascheme/${img}:${VERSION}"
          if inspect_image "$ref"; then
            echo "Image $img:$VERSION exists"
          else
            rc=$?
            if [ "$rc" -eq 2 ]; then
              echo "Authorization failure while checking $img:$VERSION. Check CI_TOKEN package permissions."
              exit 1
            fi
            echo "Image $img:$VERSION not found"
            missing+=("$img")
          fi
        done

        # GIL-enabled cpython images (tagged with GIL_VERSION, e.g. 3.14.3)
        gil_images=(cpython-tsan cpython-asan)
        gil_missing=()

        for img in "${gil_images[@]}"; do
          ref="ghcr.io/nascheme/${img}:${GIL_VERSION}"
          if inspect_image "$ref"; then
            echo "Image $img:$GIL_VERSION (GIL) exists"
          else
            rc=$?
            if [ "$rc" -eq 2 ]; then
              echo "Authorization failure while checking $img:$GIL_VERSION. Check CI_TOKEN package permissions."
              exit 1
            fi
            echo "Image $img:$GIL_VERSION (GIL) not found"
            gil_missing+=("$img")
          fi
        done

        if [ ${#missing[@]} -eq 0 ]; then
          echo "ALL_EXIST=1" >> $GITHUB_OUTPUT
          echo "No free-threaded images missing for $VERSION"
        else
          echo "ALL_EXIST=0" >> $GITHUB_OUTPUT
          printf "MISSING=%s\n" "${missing[*]}" >> $GITHUB_OUTPUT
          echo "Missing free-threaded images: ${missing[*]}"
        fi

        if [ ${#gil_missing[@]} -eq 0 ]; then
          echo "GIL_ALL_EXIST=1" >> $GITHUB_OUTPUT
          echo "No GIL-enabled images missing for $GIL_VERSION"
        else
          echo "GIL_ALL_EXIST=0" >> $GITHUB_OUTPUT
          printf "GIL_MISSING=%s\n" "${gil_missing[*]}" >> $GITHUB_OUTPUT
          echo "Missing GIL-enabled images: ${gil_missing[*]}"
        fi


    - id: dispatch_builds
      name: Dispatch builds for missing images (in order)
      if: steps.check_images.outputs.ALL_EXIST == '0'
      env:
        REPO_OWNER: ${{ github.repository_owner }}
        REPO_FULL: ${{ github.repository }}
        VERSION: ${{ steps.get_release.outputs.version }}
        DISPATCH_TOKEN: ${{ secrets.DISPATCH_TOKEN }}
        NUMPY_VERSION: ${{ steps.lib_versions.outputs.numpy_version }}
      run: |
        set -euo pipefail

        # derive repo name from full owner/repo
        REPO_NAME=${REPO_FULL#*/}
        TARGET_REF="${GITHUB_REF_NAME:-main}"

        # read missing images list
        MISSING_RAW='${{ steps.check_images.outputs.MISSING }}'
        IFS=' ' read -r -a missing <<< "$MISSING_RAW"

        # mapping from image name to workflow file
        declare -A wfmap
        wfmap["cpython-tsan"]=docker_image_cpython.yml
        wfmap["cpython-asan"]=docker_image_cpython_asan.yml
        wfmap["numpy-tsan"]=docker_image_numpy.yml
        wfmap["numpy-asan"]=docker_image_numpy_asan.yml

        # dependency chain (only dispatch dependent images after base image tag exists)
        declare -A depmap
        depmap["numpy-tsan"]="cpython-tsan"
        depmap["numpy-asan"]="cpython-asan"

        wait_for_image() {
          local img="$1"
          local tag="$2"
          local timeout_sec="${3:-5400}"   # default 90 min
          local interval="${4:-30}"
          local waited=0
          local ref="ghcr.io/nascheme/${img}:${tag}"
          local out
          while true; do
            if docker manifest inspect "$ref" >/dev/null 2>&1; then
              echo "Dependency ready: ${img}:${tag}"
              return 0
            fi

            out=$(docker manifest inspect "$ref" 2>&1 || true)
            if echo "$out" | grep -qiE 'unauthorized|authentication required|denied'; then
              echo "Authorization failure while waiting for ${img}:${tag}. Check CI_TOKEN package permissions."
              return 2
            fi

            if [ "$waited" -ge "$timeout_sec" ]; then
              echo "Timed out waiting for dependency ${img}:${tag}"
              return 1
            fi
            echo "Waiting for dependency ${img}:${tag} (${waited}s elapsed)"
            sleep "$interval"
            waited=$((waited + interval))
          done
        }

        if [ -z "${DISPATCH_TOKEN:-}" ]; then
          echo "DISPATCH_TOKEN is required but not configured."
          exit 1
        fi
        echo "Dispatch target ref: ${TARGET_REF}"

        dispatched=()
        failed=()

        for img in "${missing[@]}"; do
          wf=${wfmap[$img]}
          if [ -z "$wf" ]; then
            echo "No workflow mapping for image $img; skipping"
            continue
          fi

          dep=${depmap[$img]:-}
          if [ -n "$dep" ]; then
            echo "Image $img depends on $dep:$VERSION"
            wait_for_image "$dep" "$VERSION"
          fi

          echo "Dispatching $wf for python_version=$VERSION (image $img)"
          url="https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/actions/workflows/${wf}/dispatches"

          # Build dispatch body with library version inputs where applicable
          case "$img" in
            numpy-tsan|numpy-asan)
              body=$(jq -n --arg ref "${TARGET_REF}" --arg ver "${VERSION}" --arg nv "${NUMPY_VERSION}" \
                '{ref: $ref, inputs: { python_version: $ver, numpy_version: $nv }}')
              ;;
            *)
              body=$(jq -n --arg ref "${TARGET_REF}" --arg ver "${VERSION}" \
                '{ref: $ref, inputs: { python_version: $ver }}')
              ;;
          esac

          resp=$(mktemp)
          http_status=$(curl -sS -o "$resp" -w "%{http_code}" -X POST \
            -H "Authorization: Bearer ${DISPATCH_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            -H "Content-Type: application/json" \
            -d "$body" "$url" || true)

          msg=$(jq -r '.message // empty' "$resp" 2>/dev/null || true)
          [ -n "$msg" ] && echo "Dispatch returned HTTP $http_status: $msg" || echo "Dispatch returned HTTP $http_status"
          rm -f "$resp"

          if [ "$http_status" -lt 400 ]; then
            dispatched+=("$wf")
          else
            echo "Failed to dispatch $wf"
            failed+=("$wf:$http_status")
          fi
        done

        echo "DISPATCHED=${dispatched[*]}" >> $GITHUB_OUTPUT
        echo "FAILED=${failed[*]}" >> $GITHUB_OUTPUT
        if [ ${#failed[@]} -ne 0 ]; then
          echo "Some dispatches failed: ${failed[*]}"
          exit 1
        fi

    - id: dispatch_gil_builds
      name: Dispatch GIL-enabled builds for missing images
      if: steps.check_images.outputs.GIL_ALL_EXIST == '0'
      env:
        REPO_OWNER: ${{ github.repository_owner }}
        REPO_FULL: ${{ github.repository }}
        GIL_VERSION: ${{ steps.get_release.outputs.gil_version }}
        DISPATCH_TOKEN: ${{ secrets.DISPATCH_TOKEN }}
      run: |
        set -euo pipefail

        REPO_NAME=${REPO_FULL#*/}
        TARGET_REF="${GITHUB_REF_NAME:-main}"

        GIL_MISSING_RAW='${{ steps.check_images.outputs.GIL_MISSING }}'
        IFS=' ' read -r -a gil_missing <<< "$GIL_MISSING_RAW"

        declare -A wfmap
        wfmap["cpython-tsan"]=docker_image_cpython.yml
        wfmap["cpython-asan"]=docker_image_cpython_asan.yml

        if [ -z "${DISPATCH_TOKEN:-}" ]; then
          echo "DISPATCH_TOKEN is required but not configured."
          exit 1
        fi
        echo "Dispatch target ref: ${TARGET_REF}"

        dispatched=()
        failed=()

        for img in "${gil_missing[@]}"; do
          wf=${wfmap[$img]:-}
          if [ -z "$wf" ]; then
            echo "No workflow mapping for GIL image $img; skipping"
            continue
          fi

          echo "Dispatching $wf for python_version=$GIL_VERSION (GIL-enabled image $img)"
          url="https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/actions/workflows/${wf}/dispatches"

          body=$(jq -n --arg ref "${TARGET_REF}" --arg ver "${GIL_VERSION}" \
            '{ref: $ref, inputs: { python_version: $ver }}')

          resp=$(mktemp)
          http_status=$(curl -sS -o "$resp" -w "%{http_code}" -X POST \
            -H "Authorization: Bearer ${DISPATCH_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            -H "Content-Type: application/json" \
            -d "$body" "$url" || true)

          msg=$(jq -r '.message // empty' "$resp" 2>/dev/null || true)
          [ -n "$msg" ] && echo "Dispatch returned HTTP $http_status: $msg" || echo "Dispatch returned HTTP $http_status"
          rm -f "$resp"

          if [ "$http_status" -lt 400 ]; then
            dispatched+=("$wf")
          else
            echo "Failed to dispatch $wf for GIL-enabled build"
            failed+=("$wf:$http_status")
          fi
        done

        echo "GIL_DISPATCHED=${dispatched[*]}" >> $GITHUB_OUTPUT
        echo "GIL_FAILED=${failed[*]}" >> $GITHUB_OUTPUT
        if [ ${#failed[@]} -ne 0 ]; then
          echo "Some GIL-enabled dispatches failed: ${failed[*]}"
          exit 1
        fi

    - name: Done
      run: echo "Version check complete for ${{ matrix.python_minor }}"
